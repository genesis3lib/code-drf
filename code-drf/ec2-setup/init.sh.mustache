#!/bin/bash

# S3-Based Initialization and Deployment for Django/DRF
# Exit on any error
set -e

APP_VERSION=$1
DJANGO_SETTINGS_MODULE=$2

if [ -z "$APP_VERSION" ]; then
    echo "Usage: $0 <app-version> [django-settings-module]"
    echo "Example: $0 1.0.123"
    exit 1
fi

echo "=== Starting S3-Based Initialization and Deployment ==="
echo "=== Version: $APP_VERSION ==="

# Configure AWS CLI region for this script
export AWS_DEFAULT_REGION="{{region}}"
echo "=== AWS Region: $AWS_DEFAULT_REGION ==="

# Get AWS Account ID for bucket names (all buckets include account ID for global uniqueness)
AWS_ACCOUNT_ID=$(aws sts get-caller-identity --query Account --output text)
echo "=== AWS Account ID: $AWS_ACCOUNT_ID ==="

# 1. Set timezone
echo "=== Setting timezone ==="
sudo timedatectl set-timezone US/Central

# 2. Create directories if not exists
echo "=== Creating directory structure ==="
sudo mkdir -p /opt/{{backendModule.name}}/ec2-setup
sudo mkdir -p /opt/{{backendModule.name}}/app
sudo mkdir -p /opt/{{backendModule.name}}/env
sudo mkdir -p /opt/{{backendModule.name}}/logs
sudo mkdir -p /opt/{{backendModule.name}}/backups
sudo mkdir -p /opt/{{backendModule.name}}/venv

# 3. Install system dependencies
echo "=== Installing system dependencies ==="

# Detect OS and use appropriate package manager
if grep -q "Amazon Linux 2023" /etc/os-release 2>/dev/null; then
    echo "Detected Amazon Linux 2023"
    PKG_MGR="dnf"
    sudo dnf update -y
else
    echo "Detected Amazon Linux 2 or other"
    PKG_MGR="yum"
    sudo yum update -y
fi

# Install Python 3.11 (available on AL2023 via packages)
echo "=== Installing Python 3.11 ==="
if command -v python3.11 &> /dev/null; then
    echo "Python 3.11 is already installed:"
    python3.11 --version
    PYTHON_CMD="python3.11"
else
    echo "Installing Python 3.11..."
    if [ "$PKG_MGR" = "dnf" ]; then
        # Amazon Linux 2023 - Python 3.11 available via dnf
        sudo dnf install -y python3.11 python3.11-pip python3.11-devel
    else
        # Fallback for other systems
        sudo yum install -y python3.11 python3.11-pip python3.11-devel || \
        sudo yum install -y python3 python3-pip python3-devel
    fi

    # Verify installation
    if command -v python3.11 &> /dev/null; then
        echo "Python 3.11 installed successfully:"
        python3.11 --version
        PYTHON_CMD="python3.11"
    elif command -v python3 &> /dev/null; then
        echo "Python 3 installed:"
        python3 --version
        PYTHON_CMD="python3"
    else
        echo "Python installation failed!"
        exit 1
    fi
fi

# Export PYTHON_CMD for use later in the script
export PYTHON_CMD
echo "Using Python: $PYTHON_CMD"

# Install PostgreSQL client
echo "Installing PostgreSQL client..."
if [ "$PKG_MGR" = "dnf" ]; then
    sudo dnf install -y postgresql15 || sudo dnf install -y postgresql || echo "PostgreSQL client installation skipped"
else
    sudo yum install -y postgresql postgresql-client || sudo yum install -y postgresql15 || echo "PostgreSQL client installation skipped"
fi

# Install other dependencies
# Note: Don't install 'curl' on AL2023 - curl-minimal is pre-installed and provides the curl command
echo "Installing other dependencies..."
if [ "$PKG_MGR" = "dnf" ]; then
    sudo dnf install -y awscli jq wget unzip gcc
else
    sudo yum install -y awscli jq wget curl unzip gcc
fi

echo "=== Verifying installed packages ==="
$PYTHON_CMD --version
aws --version
jq --version
psql --version || echo "PostgreSQL verification failed"

# 4. Create {{backendModule.name}} user if not exists
echo "=== Creating {{backendModule.name}} user ==="
if ! id "{{backendModule.name}}" &>/dev/null; then
    sudo useradd -r -s /bin/bash -d /opt/{{backendModule.name}} -c "{{backendModule.name}} API Service" {{backendModule.name}}
    echo "User '{{backendModule.name}}' created successfully"
else
    echo "User '{{backendModule.name}}' already exists"
fi

# 5. Sync all EC2 setup files from S3
echo "=== Syncing all EC2 setup scripts from S3 ==="

# Determine environment for S3 bucket (fallback to django settings or production)
if [ -n "$DJANGO_SETTINGS_MODULE" ]; then
    # Extract environment from settings module (e.g., prj_myapp.settings.production -> production)
    ENV_FOR_S3=$(echo "$DJANGO_SETTINGS_MODULE" | sed 's/.*\.//')
else
    ENV_FOR_S3="production"
fi

echo "Source: s3://{{projectName}}-${ENV_FOR_S3}-ops-${AWS_ACCOUNT_ID}/ec2-setup/"
echo "Target: /opt/{{backendModule.name}}/ec2-setup/"

# Create target directory if it doesn't exist
sudo mkdir -p /opt/{{backendModule.name}}/ec2-setup

# Sync all files from S3 ec2-setup directory
if sudo aws s3 sync s3://{{projectName}}-${ENV_FOR_S3}-ops-${AWS_ACCOUNT_ID}/ec2-setup/ /opt/{{backendModule.name}}/ec2-setup/; then
    echo "Successfully synced EC2 setup scripts from S3"

    # Make all shell scripts executable
    sudo chmod +x /opt/{{backendModule.name}}/ec2-setup/*.sh

    # Set ownership for all files
    sudo chown -R {{backendModule.name}}:{{backendModule.name}} /opt/{{backendModule.name}}/ec2-setup/

    echo "Downloaded EC2 setup files:"
    ls -la /opt/{{backendModule.name}}/ec2-setup/
else
    echo "Failed to sync EC2 setup scripts from S3"
    echo "Continuing with manual setup..."
fi

# 6. Setup systemd service
echo "=== Setting up systemd service ==="
if [ -f "/opt/{{backendModule.name}}/ec2-setup/{{backendModule.name}}-api.service" ]; then
    sudo cp /opt/{{backendModule.name}}/ec2-setup/{{backendModule.name}}-api.service /etc/systemd/system/
    sudo systemctl daemon-reload
    sudo systemctl enable {{backendModule.name}}-api.service
    echo "Systemd service configured successfully"
else
    echo "Service file not found: /opt/{{backendModule.name}}/ec2-setup/{{backendModule.name}}-api.service"
    echo "Manual service setup may be required"
fi

# 7. Set ownership
echo "=== Setting ownership ==="
sudo chown -R {{backendModule.name}}:{{backendModule.name}} /opt/{{backendModule.name}}

# 8. Configure Django settings and secrets
echo "=== Configuring Django settings and secrets ==="

# Determine environment for secret name (fallback to django settings or production)
if [ -n "$DJANGO_SETTINGS_MODULE" ]; then
    ENV_FOR_SECRET=$(echo "$DJANGO_SETTINGS_MODULE" | sed 's/.*\.//')
    echo "Using Django settings module for environment: $DJANGO_SETTINGS_MODULE"
else
    ENV_FOR_SECRET="production"
    echo "No Django settings specified, defaulting to production"
fi

# Read extension-required Django settings from genesis3.json
EXTENSION_SETTINGS=""
if [ -f "/opt/{{backendModule.name}}/ec2-setup/genesis3.json" ]; then
    echo "Reading extension settings from genesis3.json..."
    # For Django, we might use different profiles/settings
    EXTENSION_SETTINGS=$(jq -r '.djangoSettings // [] | join(",")' /opt/{{backendModule.name}}/ec2-setup/genesis3.json)
    if [ -n "$EXTENSION_SETTINGS" ]; then
        echo "Found extension settings: $EXTENSION_SETTINGS"
    else
        echo "No extension settings found in genesis3.json"
    fi
else
    echo "genesis3.json not found at /opt/{{backendModule.name}}/ec2-setup/genesis3.json"
    echo "Continuing without extension settings"
fi

# Single secret name for all application and database secrets
APP_SECRET_NAME="{{projectName}}-${ENV_FOR_SECRET}-app-secrets"
echo "Looking for application secrets: $APP_SECRET_NAME"

# Start building the django.env file
echo "Creating Django environment configuration..."
TEMP_DJANGO_ENV="/tmp/django.env.$$"

# Set Django settings module
if [ -n "$DJANGO_SETTINGS_MODULE" ]; then
    SETTINGS_MODULE="$DJANGO_SETTINGS_MODULE"
else
    SETTINGS_MODULE="prj_{{projectName}}.settings.production"
fi

echo "DJANGO_SETTINGS_MODULE=$SETTINGS_MODULE" > "$TEMP_DJANGO_ENV"
echo "Set DJANGO_SETTINGS_MODULE=$SETTINGS_MODULE"

# Set APP_ENV_HOST and APP_ENV_UI based on environment
if [ "$ENV_FOR_SECRET" = "prod" ] || [ "$ENV_FOR_SECRET" = "production" ]; then
    # Production environment - no environment prefix
    APP_ENV_HOST="https://{{projectName}}-api.{{domain}}"
    APP_ENV_UI="https://{{projectName}}-ui.{{domain}}"
else
    # Non-production environment - include environment suffix
    APP_ENV_HOST="https://{{projectName}}-api-${ENV_FOR_SECRET}.{{domain}}"
    APP_ENV_UI="https://{{projectName}}-ui-${ENV_FOR_SECRET}.{{domain}}"
fi

echo "APP_ENV_HOST=$APP_ENV_HOST" >> "$TEMP_DJANGO_ENV"
echo "APP_ENV_UI=$APP_ENV_UI" >> "$TEMP_DJANGO_ENV"
echo "Set APP_ENV_HOST=$APP_ENV_HOST"
echo "Set APP_ENV_UI=$APP_ENV_UI"

# Fetch secrets from AWS Secrets Manager
echo "=== Fetching secrets from AWS Secrets Manager ==="
echo "Looking for secrets: $APP_SECRET_NAME"

if aws secretsmanager get-secret-value --secret-id "$APP_SECRET_NAME" --query 'SecretString' --output text >/dev/null 2>&1; then
    echo "Found secrets: $APP_SECRET_NAME"

    # Get the secret value and parse JSON
    SECRET_JSON=$(aws secretsmanager get-secret-value --secret-id "$APP_SECRET_NAME" --query 'SecretString' --output text)

    if [ $? -eq 0 ] && [ -n "$SECRET_JSON" ]; then
        echo "Successfully retrieved secrets JSON"

        # Dump all key-value pairs with PYTHON_DRF_ prefix
        echo "Adding secrets to Django environment:"
        echo "$SECRET_JSON" | jq -r 'to_entries[] | "PYTHON_DRF_\(.key)=\(.value)"' >> "$TEMP_DJANGO_ENV"

        if [ $? -eq 0 ]; then
            echo "Successfully parsed and added secrets to environment"
            # Show what we added (mask sensitive values)
            echo "Environment variables added:"
            echo "$SECRET_JSON" | jq -r 'to_entries[] | "PYTHON_DRF_\(.key)=***MASKED***"'
        else
            echo "Failed to parse secret JSON"
            echo "Secret JSON format may be invalid"
        fi
    else
        echo "Failed to retrieve secret value"
    fi
else
    echo "Secret not found: $APP_SECRET_NAME"
    echo "Continuing without secrets"
fi

# Construct DATABASE_URL from individual DB_* fields if not already present
if ! grep -q "^PYTHON_DRF_DATABASE_URL=" "$TEMP_DJANGO_ENV"; then
    echo "DATABASE_URL not found, checking for individual DB_* fields..."

    # Extract individual DB fields from secrets (already have PYTHON_DRF_ prefix)
    DB_ENGINE=$(grep "^PYTHON_DRF_DB_ENGINE=" "$TEMP_DJANGO_ENV" | cut -d'=' -f2)
    DB_HOST=$(grep "^PYTHON_DRF_DB_HOST=" "$TEMP_DJANGO_ENV" | cut -d'=' -f2)
    DB_PORT=$(grep "^PYTHON_DRF_DB_PORT=" "$TEMP_DJANGO_ENV" | cut -d'=' -f2)
    DB_NAME=$(grep "^PYTHON_DRF_DB_NAME=" "$TEMP_DJANGO_ENV" | cut -d'=' -f2)
    DB_USERNAME=$(grep "^PYTHON_DRF_DB_USERNAME=" "$TEMP_DJANGO_ENV" | cut -d'=' -f2)
    DB_PASSWORD=$(grep "^PYTHON_DRF_DB_PASSWORD=" "$TEMP_DJANGO_ENV" | cut -d'=' -f2)

    if [ -n "$DB_HOST" ] && [ -n "$DB_NAME" ] && [ -n "$DB_USERNAME" ]; then
        # URL-encode the password (handle special characters)
        ENCODED_PASSWORD=$(python3 -c "import urllib.parse; print(urllib.parse.quote('$DB_PASSWORD', safe=''))")

        # Default engine to postgres if not specified
        DB_ENGINE=${DB_ENGINE:-postgres}
        DB_PORT=${DB_PORT:-5432}

        # Construct DATABASE_URL
        DATABASE_URL="postgresql://${DB_USERNAME}:${ENCODED_PASSWORD}@${DB_HOST}:${DB_PORT}/${DB_NAME}"
        echo "PYTHON_DRF_DATABASE_URL=$DATABASE_URL" >> "$TEMP_DJANGO_ENV"
        echo "Constructed DATABASE_URL from DB_* fields"
    else
        echo "Warning: No database configuration found in secrets"
        echo "Application may fail to start without database connection"
    fi
else
    echo "DATABASE_URL already present in secrets"
fi

# Final summary
echo "Secrets configuration completed"

# Move temp file to final location
sudo mv "$TEMP_DJANGO_ENV" /opt/{{backendModule.name}}/env/django.env
sudo chown {{backendModule.name}}:{{backendModule.name}} /opt/{{backendModule.name}}/env/django.env
sudo chmod 644 /opt/{{backendModule.name}}/env/django.env

echo "Final Django environment configuration:"
echo "DJANGO_SETTINGS_MODULE=$(grep DJANGO_SETTINGS_MODULE /opt/{{backendModule.name}}/env/django.env | cut -d'=' -f2)"
echo "Additional environment variables: $(grep -v DJANGO_SETTINGS_MODULE /opt/{{backendModule.name}}/env/django.env | wc -l)"

# 9. Backup existing app
echo "=== Backing up existing application ==="
if [ -d "/opt/{{backendModule.name}}/app" ] && [ "$(ls -A /opt/{{backendModule.name}}/app)" ]; then
    BACKUP_NAME="app.backup.$(date +%Y%m%d_%H%M%S)"
    sudo mv /opt/{{backendModule.name}}/app /opt/{{backendModule.name}}/backups/$BACKUP_NAME
    sudo mkdir -p /opt/{{backendModule.name}}/app
    echo "Existing app backed up as: $BACKUP_NAME"
else
    echo "No existing app found, skipping backup"
fi

# 10. Download new app from S3
echo "=== Downloading new application from S3 ==="
if sudo aws s3 sync "s3://{{projectName}}-${ENV_FOR_S3}-ops-${AWS_ACCOUNT_ID}/app/${APP_VERSION}/" /opt/{{backendModule.name}}/app/; then
    echo "Successfully downloaded app version $APP_VERSION from S3"
    sudo chown -R {{backendModule.name}}:{{backendModule.name}} /opt/{{backendModule.name}}/app
else
    echo "Failed to download app from S3"
    exit 1
fi

# 11. Setup Python virtual environment and install dependencies
echo "=== Setting up Python virtual environment ==="
cd /opt/{{backendModule.name}}

# Get required Python version (major.minor)
REQUIRED_PYTHON_VERSION=$($PYTHON_CMD --version 2>&1 | cut -d' ' -f2 | cut -d'.' -f1,2)
echo "Required Python version: $REQUIRED_PYTHON_VERSION"

# Check if venv exists and has correct Python version
RECREATE_VENV="false"
if [ -d "/opt/{{backendModule.name}}/venv/bin" ]; then
    if [ -f "/opt/{{backendModule.name}}/venv/bin/python" ]; then
        VENV_PYTHON_VERSION=$(/opt/{{backendModule.name}}/venv/bin/python --version 2>&1 | cut -d' ' -f2 | cut -d'.' -f1,2)
        echo "Existing venv Python version: $VENV_PYTHON_VERSION"
        if [ "$VENV_PYTHON_VERSION" != "$REQUIRED_PYTHON_VERSION" ]; then
            echo "Python version mismatch! Venv has $VENV_PYTHON_VERSION but need $REQUIRED_PYTHON_VERSION"
            RECREATE_VENV="true"
        else
            echo "Venv Python version matches required version"
        fi
    else
        echo "Venv exists but Python binary not found - will recreate"
        RECREATE_VENV="true"
    fi
else
    echo "No existing venv found - will create new one"
    RECREATE_VENV="true"
fi

# Delete and recreate venv if needed
if [ "$RECREATE_VENV" = "true" ]; then
    echo "Removing old venv and creating new one with Python $REQUIRED_PYTHON_VERSION..."
    sudo rm -rf /opt/{{backendModule.name}}/venv
    sudo mkdir -p /opt/{{backendModule.name}}/venv
    sudo chown {{backendModule.name}}:{{backendModule.name}} /opt/{{backendModule.name}}/venv
    echo "Creating virtual environment using $PYTHON_CMD..."
    sudo -u {{backendModule.name}} $PYTHON_CMD -m venv /opt/{{backendModule.name}}/venv

    # Verify venv was created with correct Python
    if [ -f "/opt/{{backendModule.name}}/venv/bin/python" ]; then
        CREATED_VERSION=$(/opt/{{backendModule.name}}/venv/bin/python --version 2>&1)
        echo "Venv created with: $CREATED_VERSION"
    else
        echo "Failed to create venv!"
        exit 1
    fi
fi

# Install requirements
echo "Installing Python dependencies..."
if [ -f "/opt/{{backendModule.name}}/app/requirements.txt" ]; then
    sudo -u {{backendModule.name}} /opt/{{backendModule.name}}/venv/bin/pip install --upgrade pip
    sudo -u {{backendModule.name}} /opt/{{backendModule.name}}/venv/bin/pip install -r /opt/{{backendModule.name}}/app/requirements.txt
    echo "Python dependencies installed successfully"
else
    echo "requirements.txt not found"
    exit 1
fi

# 12. Run Django collectstatic
echo "=== Running Django collectstatic ==="
cd /opt/{{backendModule.name}}/app
sudo -u {{backendModule.name}} /opt/{{backendModule.name}}/venv/bin/python manage.py collectstatic --noinput || echo "collectstatic skipped or failed"

# 13. Run Django migrations
echo "=== Running Django migrations ==="
sudo -u {{backendModule.name}} /opt/{{backendModule.name}}/venv/bin/python manage.py migrate --noinput || echo "migrations skipped or failed"

# 14. Restart service
echo "=== Restarting {{backendModule.name}}-api service ==="
sudo systemctl restart {{backendModule.name}}-api.service

# Verify service is running
echo "=== Verifying service startup ==="
sleep 5

RETRY_COUNT=0
MAX_RETRIES=24
SLEEP_TIME=10

while [ $RETRY_COUNT -lt $MAX_RETRIES ]; do
    if systemctl is-active --quiet {{backendModule.name}}-api.service; then
        echo "Service is running successfully!"
        echo
        echo "=== Service Status ==="
        sudo systemctl status {{backendModule.name}}-api.service --no-pager -l
        echo
        echo "=== Recent Logs ==="
        sudo journalctl -u {{backendModule.name}}-api.service -n 10 --no-pager
        echo
        echo "=== Current App Version ==="
        echo "$APP_VERSION"
        echo
        echo "=== Initialization and Deployment completed successfully ==="
        exit 0
    fi

    RETRY_COUNT=$((RETRY_COUNT + 1))
    echo "Service not ready yet, waiting... (attempt $RETRY_COUNT/$MAX_RETRIES)"
    sleep $SLEEP_TIME
done

# If we get here, the service failed to start
echo "Service failed to start after $((MAX_RETRIES * SLEEP_TIME)) seconds."
echo
echo "=== Service Status ==="
sudo systemctl status {{backendModule.name}}-api.service --no-pager -l
echo
echo "=== Recent Error Logs ==="
sudo journalctl -u {{backendModule.name}}-api.service -n 20 --no-pager
exit 1
