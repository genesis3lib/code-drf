name: Code-300-Server
on:
  push:
  workflow_dispatch:

permissions:
  contents: read
  checks: write
  id-token: write

env:
  TF_VERSION: "1.12.2"
  AWS_REGION: {{region}}

jobs:
  server-operations:
    runs-on: ubuntu-latest
    steps:
      - name: Version of AWS CLI
        run: |
          echo "AWS CLI version:"
          which aws
          aws --version

      - name: Checkout code
        uses: actions/checkout@v4

      - name: Env setup
        run: |

          # Set environment variables
          echo "BRANCH={{{githubVarsOpen}}} github.ref_name  {{{githubVarsClose}}}" >> $GITHUB_ENV
          if [[ "{{{githubVarsOpen}}} github.ref_name  {{{githubVarsClose}}}" = "main" || "{{{githubVarsOpen}}} github.ref_name  {{{githubVarsClose}}}" = "production" ]]; then
            echo "ENVIRONMENT=prod" >> $GITHUB_ENV
          else
            BRANCH_ENV=$(echo "{{{githubVarsOpen}}} github.ref_name  {{{githubVarsClose}}}" | sed "s/\\//-/g")
            echo "ENVIRONMENT=$BRANCH_ENV" >> $GITHUB_ENV
          fi

          echo "Environment setup completed: {{{githubVarsOpen}}} github.ref_name  {{{githubVarsClose}}}"

      - name: Credential for AWS
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: arn:aws:iam::{{{githubVarsOpen}}} vars.AWS_ACCOUNT_ID {{{githubVarsClose}}}:role/{{projectName}}-{{{githubVarsOpen}}} env.ENVIRONMENT  {{{githubVarsClose}}}-ops-deploy-ec2-role
          aws-region: {{{githubVarsOpen}}} env.AWS_REGION  {{{githubVarsClose}}}

      - name: Setup Environment
        run: |
          echo "Event name: {{{githubVarsOpen}}} github.event_name  {{{githubVarsClose}}}"
          echo "Branch: {{{githubVarsOpen}}} env.BRANCH  {{{githubVarsClose}}}"
          echo "Environment: {{{githubVarsOpen}}} env.ENVIRONMENT  {{{githubVarsClose}}}"

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: {{{githubVarsOpen}}} env.TF_VERSION  {{{githubVarsClose}}}
          terraform_wrapper: false

      - name: Get Terraform Outputs
        run: |
          cd {{opsModule.moduleId}}/terraform
          echo "Getting Terraform outputs for {{{githubVarsOpen}}} env.ENVIRONMENT  {{{githubVarsClose}}} environment..."

          # Get AWS account ID for state bucket name
          AWS_ACCOUNT_ID=$(aws sts get-caller-identity --query Account --output text)
          STATE_BUCKET="{{projectName}}-tfstate-${AWS_ACCOUNT_ID}"
          echo "Using state bucket: ${STATE_BUCKET}"

          # Initialize Terraform to access state
          terraform init -backend-config=backend-${ENVIRONMENT}.hcl -backend-config="bucket=${STATE_BUCKET}" -input=false

          # Get the ops bucket name from Terraform outputs
          OPS_BUCKET=$(terraform output -raw ops_bucket_name 2>/dev/null || echo "")

          if [ -z "$OPS_BUCKET" ]; then
            echo "Could not get ops bucket from Terraform outputs"
            echo "Available Terraform outputs:"
            terraform output
            echo "Infrastructure may not be deployed yet - run deploy_apply first"
            exit 1
          fi

          echo "Found ops bucket: $OPS_BUCKET"
          echo "OPS_BUCKET=$OPS_BUCKET" >> $GITHUB_ENV
        env:
          AWS_DEFAULT_REGION: {{{githubVarsOpen}}} env.AWS_REGION  {{{githubVarsClose}}}

      - name: Set Deployment Environment Variables
        run: |
          echo "Setting up deployment environment variables..."

          # Set DJANGO_SETTINGS_MODULE based on ENVIRONMENT
          echo "DJANGO_SETTINGS_MODULE=prj_{{projectName}}.settings.{{{githubVarsOpen}}} env.ENVIRONMENT  {{{githubVarsClose}}}" >> $GITHUB_ENV
          echo "DJANGO_SETTINGS_MODULE set to: prj_{{projectName}}.settings.{{{githubVarsOpen}}} env.ENVIRONMENT  {{{githubVarsClose}}}"

          echo "Environment Variables Set:"
          echo "  DJANGO_SETTINGS_MODULE: prj_{{projectName}}.settings.{{{githubVarsOpen}}} env.ENVIRONMENT  {{{githubVarsClose}}}"
          echo "  OPS_BUCKET: ${OPS_BUCKET}"

      - name: Get EC2 Instances by Tags
        run: |
          echo "Finding EC2 instances by tags..."
          echo "Looking for instances with Project={{projectName}} and Environment={{{githubVarsOpen}}} env.ENVIRONMENT  {{{githubVarsClose}}}"

          # Query EC2 instances by tags
          EC2_INSTANCES=$(aws ec2 describe-instances \
            --filters \
              "Name=tag:Project,Values={{projectName}}" \
              "Name=tag:Environment,Values={{{githubVarsOpen}}} env.ENVIRONMENT  {{{githubVarsClose}}}" \
              "Name=instance-state-name,Values=running" \
            --query 'Reservations[*].Instances[*].InstanceId' \
            --output text | tr '\n\t ' ',' | sed 's/,,*/,/g' | sed 's/^,//g' | sed 's/,$//g')

          if [ -n "${EC2_INSTANCES}" ] && [ "${EC2_INSTANCES}" != "" ]; then
            echo "EC2_INSTANCES=${EC2_INSTANCES}" >> $GITHUB_ENV
            echo "Found running instances: ${EC2_INSTANCES}"
          else
            echo "No running instances found with tags Project={{projectName}} and Environment={{{githubVarsOpen}}} env.ENVIRONMENT  {{{githubVarsClose}}}"
            echo "This could indicate:"
            echo "  1. Instances are still launching"
            echo "  2. Instances failed to start properly"
            echo "  3. Infrastructure deployment is incomplete"
            echo ""
            echo "All instances in environment:"
            aws ec2 describe-instances \
              --filters \
                "Name=tag:Project,Values={{projectName}}" \
                "Name=tag:Environment,Values={{{githubVarsOpen}}} env.ENVIRONMENT  {{{githubVarsClose}}}" \
              --query 'Reservations[*].Instances[*].{InstanceId:InstanceId,State:State.Name,Name:Tags[?Key==`Name`].Value|[0]}' \
              --output table
            exit 1
          fi

      - name: Setup Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.12'

      - name: Deploy - Add build info
        run: |
          mkdir -p {{backendModule.moduleId}}
          echo "version = {" > {{backendModule.moduleId}}/version.py
          echo "    'build': '{{{githubVarsOpen}}} github.run_number {{{githubVarsClose}}}'," >> {{backendModule.moduleId}}/version.py
          echo "    'attempt': '{{{githubVarsOpen}}} github.run_attempt {{{githubVarsClose}}}'," >> {{backendModule.moduleId}}/version.py
          echo "    'action': '{{{githubVarsOpen}}} github.action {{{githubVarsClose}}}'," >> {{backendModule.moduleId}}/version.py
          echo "    'modifiedDate': '{{{githubVarsOpen}}} github.event.repository.updated_at {{{githubVarsClose}}}'," >> {{backendModule.moduleId}}/version.py
          echo "    'sha': '$(git rev-parse --short HEAD)'" >> {{backendModule.moduleId}}/version.py
          echo "}" >> {{backendModule.moduleId}}/version.py

      - name: Deploy - Run Tests
        run: |
          cd {{backendModule.moduleId}}
          pip install -r requirements.txt
          python -m pytest --tb=short || echo "Tests skipped or failed"

      - name: Deploy - Sync App to S3
        run: |
          APP_VERSION="1.0.{{{githubVarsOpen}}} github.run_number  {{{githubVarsClose}}}.{{{githubVarsOpen}}} github.run_attempt  {{{githubVarsClose}}}"
          echo "Syncing app to S3 ops bucket: ${OPS_BUCKET}/app/${APP_VERSION}/"
          echo "App Version: ${APP_VERSION}"

          # Verify source directory exists
          if [ ! -d "{{backendModule.moduleId}}" ]; then
            echo "Source directory {{backendModule.moduleId}} not found"
            exit 1
          fi

          # Sync the app directory to S3
          echo "Syncing app to S3..."
          if aws s3 sync ./{{backendModule.moduleId}}/ "s3://${OPS_BUCKET}/app/${APP_VERSION}/" \
            --exclude "*.pyc" \
            --exclude "__pycache__/*" \
            --exclude ".pytest_cache/*" \
            --exclude "*.egg-info/*" \
            --exclude ".git/*" \
            --region {{{githubVarsOpen}}} env.AWS_REGION  {{{githubVarsClose}}}; then
            echo "Successfully synced app to S3 ops bucket"
            echo "APP_VERSION=${APP_VERSION}" >> $GITHUB_ENV

            # Verify what was uploaded
            echo "Verifying uploaded files:"
            aws s3 ls "s3://${OPS_BUCKET}/app/${APP_VERSION}/" --region {{{githubVarsOpen}}} env.AWS_REGION  {{{githubVarsClose}}} | head -20
          else
            echo "Failed to sync app to S3 ops bucket: ${OPS_BUCKET}"
            exit 1
          fi

      - name: Deploy - Sync EC2 Setup Scripts to S3
        run: |
          echo "Syncing latest EC2 setup scripts from Git to S3..."
          echo "Source: ./{{backendModule.moduleId}}/ec2-setup/"
          echo "Target: s3://${OPS_BUCKET}/ec2-setup/"

          # Verify source directory exists
          if [ ! -d "./{{backendModule.moduleId}}/ec2-setup" ]; then
            echo "Source directory ./{{backendModule.moduleId}}/ec2-setup not found"
            exit 1
          fi

          # Copy genesis3.json to ec2-setup directory for deployment
          if [ -f "./genesis3.json" ]; then
            echo "Copying genesis3.json to ec2-setup directory..."
            cp ./genesis3.json ./{{backendModule.moduleId}}/ec2-setup/genesis3.json
            echo "genesis3.json copied"
          else
            echo "genesis3.json not found in project root"
          fi

          # Show what we're about to sync
          echo "Files to sync:"
          ls -la ./{{backendModule.moduleId}}/ec2-setup/

          # Sync EC2 setup scripts to S3 with delete flag to remove old files
          if aws s3 sync ./{{backendModule.moduleId}}/ec2-setup/ "s3://${OPS_BUCKET}/ec2-setup/" --delete --region {{{githubVarsOpen}}} env.AWS_REGION  {{{githubVarsClose}}}; then
            echo "Successfully synced EC2 setup scripts to S3"

            # Verify what was uploaded
            echo "Verifying uploaded files:"
            aws s3 ls "s3://${OPS_BUCKET}/ec2-setup/" --region {{{githubVarsOpen}}} env.AWS_REGION  {{{githubVarsClose}}}
          else
            echo "Failed to sync EC2 setup scripts to S3"
            exit 1
          fi

      - name: Deploy - Copy EC2 Setup Scripts and Initialize
        run: |
          echo "Preparing EC2 instances with setup scripts..."

          # Convert comma-separated instances to space-separated for AWS CLI
          INSTANCE_LIST=$(echo "${EC2_INSTANCES}" | tr ',' ' ')
          echo "Target instances: ${INSTANCE_LIST}"

          # Copy ec2-setup scripts from S3 and run init.sh
          echo "Copying EC2 setup scripts and initializing instances..."
          INIT_COMMAND_ID=$(aws ssm send-command \
            --instance-ids ${INSTANCE_LIST} \
            --document-name "AWS-RunShellScript" \
            --parameters 'commands=[
              "echo \"=== Syncing EC2 setup scripts from S3 ===\"",
              "sudo mkdir -p /opt/{{backendModule.name}}/ec2-setup",
              "aws s3 sync s3://'${OPS_BUCKET}'/ec2-setup/ /opt/{{backendModule.name}}/ec2-setup/ --region '${AWS_REGION}'",
              "sudo chmod +x /opt/{{backendModule.name}}/ec2-setup/*.sh",
              "echo \"=== Running initialization script ===\"",
              "sudo /opt/{{backendModule.name}}/ec2-setup/init.sh '${APP_VERSION}' '${DJANGO_SETTINGS_MODULE}'"
            ]' \
            --timeout-seconds 1800 \
            --query 'Command.CommandId' \
            --output text)

          echo "EC2 Setup Command ID: ${INIT_COMMAND_ID}"

          echo "Waiting for EC2 setup and initialization to complete..."

          # Convert instances to array for status checking
          IFS=' ' read -ra INSTANCE_ARRAY <<< "${INSTANCE_LIST}"

          # Wait for command completion on all instances
          for i in {1..120}; do
            ALL_COMPLETE=true
            ALL_SUCCESS=true

            echo "=== Checking initialization status (attempt ${i}/120) ==="

            for INSTANCE in "${INSTANCE_ARRAY[@]}"; do
              # Trim whitespace
              INSTANCE=$(echo "${INSTANCE}" | xargs)

              STATUS=$(aws ssm get-command-invocation \
                --command-id "${INIT_COMMAND_ID}" \
                --instance-id "${INSTANCE}" \
                --query 'Status' \
                --output text 2>/dev/null || echo "InProgress")

              echo "Instance ${INSTANCE}: ${STATUS}"

              if [ "${STATUS}" = "Failed" ]; then
                echo "Initialization failed on instance ${INSTANCE}"
                echo "=== Error Output for ${INSTANCE} ==="
                aws ssm get-command-invocation \
                  --command-id "${INIT_COMMAND_ID}" \
                  --instance-id "${INSTANCE}" \
                  --query 'StandardErrorContent' \
                  --output text
                echo "=== Standard Output for ${INSTANCE} ==="
                aws ssm get-command-invocation \
                  --command-id "${INIT_COMMAND_ID}" \
                  --instance-id "${INSTANCE}" \
                  --query 'StandardOutputContent' \
                  --output text
                exit 1
              elif [ "${STATUS}" != "Success" ]; then
                ALL_SUCCESS=false
                if [ "${STATUS}" = "InProgress" ]; then
                  ALL_COMPLETE=false
                fi
              fi
            done

            if [ "${ALL_SUCCESS}" = "true" ]; then
              echo "Initialization completed successfully on all instances"

              # Show successful output from all instances
              echo "Initialization results:"
              for INSTANCE in "${INSTANCE_ARRAY[@]}"; do
                INSTANCE=$(echo "${INSTANCE}" | xargs)
                echo "Instance ${INSTANCE} initialization output (last 20 lines):"
                aws ssm get-command-invocation \
                  --command-id "${INIT_COMMAND_ID}" \
                  --instance-id "${INSTANCE}" \
                  --query 'StandardOutputContent' \
                  --output text | tail -n 20
                echo
              done
              break
            fi

            if [ "${ALL_COMPLETE}" = "true" ]; then
              echo "Some instances completed but not all succeeded"
              exit 1
            fi

            sleep 15
          done

          # If we reach here without success, it timed out
          if [ "${ALL_SUCCESS}" != "true" ]; then
            echo "Initialization timed out after 30 minutes"
            # Show any available output even on timeout
            for INSTANCE in "${INSTANCE_ARRAY[@]}"; do
              INSTANCE=$(echo "${INSTANCE}" | xargs)
              echo "--- Instance ${INSTANCE} Output ---"
              aws ssm get-command-invocation \
                --command-id "${INIT_COMMAND_ID}" \
                --instance-id "${INSTANCE}" \
                --query 'StandardOutputContent' \
                --output text || true
              echo "--- Instance ${INSTANCE} Errors ---"
              aws ssm get-command-invocation \
                --command-id "${INIT_COMMAND_ID}" \
                --instance-id "${INSTANCE}" \
                --query 'StandardErrorContent' \
                --output text || true
              echo
            done
            exit 1
          fi
          echo "EC2 setup and initialization completed"
          echo "Deployment to {{{githubVarsOpen}}} env.ENVIRONMENT  {{{githubVarsClose}}} environment completed successfully!"
          echo "Summary:"
          echo "  - App Version: ${APP_VERSION}"
          echo "  - Environment: {{{githubVarsOpen}}} env.ENVIRONMENT  {{{githubVarsClose}}}"
          echo "  - Django Settings: ${DJANGO_SETTINGS_MODULE}"
          echo "  - Instances: ${EC2_INSTANCES}"
          echo "  - Service: {{backendModule.name}}-api.service"

      - name: Enable ALB Health Checks
        run: |
          echo "Checking if ALB health checks are already enabled..."

          # Check current health check type
          CURRENT_HEALTH_CHECK=$(aws autoscaling describe-auto-scaling-groups \
            --auto-scaling-group-names "{{projectName}}-{{{githubVarsOpen}}} env.ENVIRONMENT  {{{githubVarsClose}}}-asg" \
            --query 'AutoScalingGroups[0].HealthCheckType' \
            --output text 2>/dev/null || echo "NONE")

          echo "Current health check type: ${CURRENT_HEALTH_CHECK}"

          if [ "${CURRENT_HEALTH_CHECK}" = "ELB" ]; then
            echo "ALB health checks are already enabled"
            echo "Current ASG health check configuration:"
            aws autoscaling describe-auto-scaling-groups \
              --auto-scaling-group-names "{{projectName}}-{{{githubVarsOpen}}} env.ENVIRONMENT  {{{githubVarsClose}}}-asg" \
              --query 'AutoScalingGroups[0].{HealthCheckType:HealthCheckType,HealthCheckGracePeriod:HealthCheckGracePeriod}' \
              --output table
          else
            echo "Enabling ALB health checks for Auto Scaling Group..."

            # Run the enable health checks script
            cd {{opsModule.moduleId}}/helper
            chmod +x enable-health-checks.sh
            ./enable-health-checks.sh {{{githubVarsOpen}}} env.ENVIRONMENT  {{{githubVarsClose}}}

            echo "ALB health checks enabled successfully!"
          fi
